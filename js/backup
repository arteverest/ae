(function(root) {
    'use strict';

    var Surface = root.Surface = function Surface() {
        return this.warmUp();
    };

    Surface.prototype.warmUp = function() {

        function setupShader(mainColor) {
            // shaderScene.remove(p);
            // shaderCanvasRenderer.clear();
            i = new FSS.Plane(1.2 * shaderCanvasRenderer.width, 1.2 * shaderCanvasRenderer.height, 8, 8);
            h = new FSS.Material("#ffffff", mainColor);
            p = new FSS.Mesh(i, h);
            var e, t;
            for (e = i.vertices.length - 1; e >= 0; e--) {
                t = i.vertices[e];
                t.anchor = FSS.Vector3.clone(t.position);
                t.step = FSS.Vector3.create(Utils.randomFloat(.4, 1), Utils.randomFloat(.4, 1), Utils.randomFloat(.4, 1));
                t.time = Utils.randomFloat(0, Math.PIM2)
            }
            shaderScene.add(p)
        }

        function setupShaderLight() {
            d = new FSS.Light("#111122", "#ffffff");
            shaderScene.add(d)
        }

        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        var shaderCanvasRenderer = new FSS.CanvasRenderer;
        var shaderScene = new FSS.Scene;
        var i;
        var proxy = {},
            colorConfig = {},
            l, c, i, h, p, d, m, g = Date.now();
        colorConfig.hsl = null;
        colorConfig.hsl1 = null;
        colorConfig.hsl2 = null;

        proxy.setup = function(mainColor, secondaryColor) {

            colorConfig.hsl = tinycolor(mainColor).toHsl();
            colorConfig.hsl1 = tinycolor(mainColor).toHsl();
            colorConfig.hsl2 = tinycolor(secondaryColor).toHsl();

            setupShader(mainColor);
            setupShaderLight();

            shaderCanvasRenderer.element.style.position = "absolute";
            shaderCanvasRenderer.element.style.top = "0";
            shaderCanvasRenderer.element.style.right = "0";
            shaderCanvasRenderer.element.style.zIndex = "1000";

            // x = (new TWEEN.Tween(colorConfig.hsl)).to({
            //     h: colorConfig.hsl2.h,
            //     s: colorConfig.hsl2.s,
            //     l: colorConfig.hsl2.l
            // }, 5e3).repeat(Infinity).yoyo(!0).delay(5e3).easing(TWEEN.Easing.Cubic.InOut).onUpdate(function() {
            //     var e = tinycolor(f.hsl).toHexString();
            //     y = e;
            //     h.diffuse.set(e, h.diffuse.opacity)
            // }).start();

            // var tween = (new TWEEN.Tween(colorConfig.hsl));
            // tween.to({
            //     h: colorConfig.hsl2.h,
            //     s: colorConfig.hsl2.s,
            //     l: colorConfig.hsl2.l
            // }, 5e3);
            // tween.repeat(Infinity);
            // tween.yoyo(!0);
            // tween.delay(5e3);
            // tween.easing(TWEEN.Easing.Cubic.InOut);
            // tween.onUpdate(function() {
            //     var e = tinycolor(f.hsl).toHexString();
            //     y = e;
            //     h.diffuse.set(e, h.diffuse.opacity)
            // });
            // tween.start();

        };
        proxy.setSize = function(t) {
            n.setSize(t.width, t.height);
            e.width = t.width;
            e.height = t.height;
            i.width = t.width;
            i.height = t.height;
            setupShader()
        };
        proxy.update = function() {
            // context.beginPath();
            // context.rect(0, 0, canvas.width, canvas.height);
            // context.fillStyle = y;
            context.fill();
            m = Date.now() - g;
            d.setPosition(shaderCanvasRenderer.width * .6 * Math.sin(m * .001), 25, shaderCanvasRenderer.height * .24 + Math.sin(m * .005) * 35);
            // var r = MESH.depth / 2;
            // for (var v = i.vertices.length - 1; v >= 0; v--) {
            //     var vertex = i.vertices[v];
            //     var ox = Math.sin(vertex.time + vertex.step[0] * m * MESH.speed);
            //     var oy = Math.cos(vertex.time + vertex.step[1] * m * MESH.speed);
            //     var oz = Math.sin(vertex.time + vertex.step[2] * m * MESH.speed);
            //     FSS.Vector3.set(vertex.position, MESH.xRange * i.segmentWidth * ox, MESH.yRange * i.sliceHeight * oy, MESH.zRange * r * oz - r);
            //     FSS.Vector3.add(vertex.position, vertex.anchor)
            // }
            // i.dirty = !0
        };
        proxy.render = function(t, i) {
            var s = canvas.width,
                o = canvas.height;
            if (i) {
                s *= 550 / s;
                o *= 650 / o
            }
            shaderCanvasRenderer.render(shaderScene);
            t.drawImage(canvas, 0, 0);
            t.drawImage(shaderCanvasRenderer.element, 0, 0, shaderCanvasRenderer.width, shaderCanvasRenderer.height, 0, 0, s, o)
        };

        var COLOR1 = "#ff6666";
        var COLOR2 = "#990000";

        proxy.setup(COLOR1, COLOR2);

        return proxy;
    };


}(window));


////////////////////



    var Surface = root.Surface = function Surface() {
        return this.warmUp();
    };

    Surface.prototype.warmUp = function() {

        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        var shaderCanvasRenderer = new FSS.CanvasRenderer;
        var shaderScene = new FSS.Scene;

        var i;
        var proxy = {},
            colorConfig = {},
            l, c, i, h, p, d, m, g = Date.now();
        colorConfig.hsl = null;
        colorConfig.hsl1 = null;
        colorConfig.hsl2 = null;

        var light = null;


        function setupShader(mainColor) {
            shaderScene.remove(p);
            shaderCanvasRenderer.clear();
            i = new FSS.Plane(1.2 * shaderCanvasRenderer.width, 1.2 * shaderCanvasRenderer.height, 8, 8);
            h = new FSS.Material("#ffffff", mainColor);
            p = new FSS.Mesh(i, h);
            var e, t;
            for (e = i.vertices.length - 1; e >= 0; e--) {
                t = i.vertices[e];
                t.anchor = FSS.Vector3.clone(t.position);
                t.step = FSS.Vector3.create(Utils.randomFloat(.4, 1), Utils.randomFloat(.4, 1), Utils.randomFloat(.4, 1));
                t.time = Utils.randomFloat(0, Math.PIM2)
            }
            shaderScene.add(p)
        }

        function setupShaderLight() {
            var light = new FSS.Light("#111122", "#ffffff");
            shaderScene.add(light);

            return light;
        }

        proxy.setup = function(mainColor, secondaryColor) {

            colorConfig.hsl = tinycolor(mainColor).toHsl();
            colorConfig.hsl1 = tinycolor(mainColor).toHsl();
            colorConfig.hsl2 = tinycolor(secondaryColor).toHsl();

            setupShader(mainColor);
            light = setupShaderLight();

            shaderCanvasRenderer.element.style.position = "absolute";
            shaderCanvasRenderer.element.style.top = "0";
            shaderCanvasRenderer.element.style.right = "0";
            shaderCanvasRenderer.element.style.zIndex = "1000";

            // x = (new TWEEN.Tween(colorConfig.hsl)).to({
            //     h: colorConfig.hsl2.h,
            //     s: colorConfig.hsl2.s,
            //     l: colorConfig.hsl2.l
            // }, 5e3).repeat(Infinity).yoyo(!0).delay(5e3).easing(TWEEN.Easing.Cubic.InOut).onUpdate(function() {
            //     var e = tinycolor(f.hsl).toHexString();
            //     y = e;
            //     h.diffuse.set(e, h.diffuse.opacity)
            // }).start();

            // var tween = (new TWEEN.Tween(colorConfig.hsl));
            // tween.to({
            //     h: colorConfig.hsl2.h,
            //     s: colorConfig.hsl2.s,
            //     l: colorConfig.hsl2.l
            // }, 5e3);
            // tween.repeat(Infinity);
            // tween.yoyo(!0);
            // tween.delay(5e3);
            // tween.easing(TWEEN.Easing.Cubic.InOut);
            // tween.onUpdate(function() {
            //     var e = tinycolor(f.hsl).toHexString();
            //     y = e;
            //     h.diffuse.set(e, h.diffuse.opacity)
            // });
            // tween.start();

        };
        proxy.setSize = function(mask) {
            shaderCanvasRenderer.setSize(mask.width, mask.height);
            canvas.width = mask.width;
            canvas.height = mask.height;
            i.width = mask.width;
            i.height = mask.height;
            setupShader();
        };
        proxy.update = function() {
            // context.beginPath();
            // context.rect(0, 0, canvas.width, canvas.height);
            // context.fillStyle = y;
            context.fill();
            m = Date.now() - g;
            light.setPosition(shaderCanvasRenderer.width * .6 * Math.sin(m * .001), 25, shaderCanvasRenderer.height * .24 + Math.sin(m * .005) * 35);
            var r = MESH.depth / 2;
            for (var v = i.vertices.length - 1; v >= 0; v--) {
                var vertex = i.vertices[v];
                var ox = Math.sin(vertex.time + vertex.step[0] * m * MESH.speed);
                var oy = Math.cos(vertex.time + vertex.step[1] * m * MESH.speed);
                var oz = Math.sin(vertex.time + vertex.step[2] * m * MESH.speed);
                FSS.Vector3.set(vertex.position, MESH.xRange * i.segmentWidth * ox, MESH.yRange * i.sliceHeight * oy, MESH.zRange * r * oz - r);
                FSS.Vector3.add(vertex.position, vertex.anchor)
            }
            i.dirty = !0
        };
        proxy.render = function(t, i) {
            var s = canvas.width,
                o = canvas.height;
            if (i) {
                s *= 550 / s;
                o *= 650 / o
            }
            shaderCanvasRenderer.render(shaderScene);
            t.drawImage(canvas, 0, 0);
            t.drawImage(shaderCanvasRenderer.element, 0, 0, shaderCanvasRenderer.width, shaderCanvasRenderer.height, 0, 0, s, o)
        };

        var COLOR1 = "#ff6666";
        var COLOR2 = "#990000";

        proxy.setup(COLOR1, COLOR2);

        return proxy;
    };
